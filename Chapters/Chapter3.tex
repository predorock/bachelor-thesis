\lhead{\emph{Capitolo 3}}
\chapter{Case Study: L'approccio ibrido con tecnologie web}

L'approccio ibrido con tecnologie web è stato scelto durante lo svolgimento del tirocinio presso la ditta BigThink SRL, in quanto si adattava meglio ad una serie di tecnologie già utilizzate dall'azienda.
Durante la permanenza in azienda ho svolto il lavoro di Frontend Developer di Web Applications, in particolare mi occupavo dello sviluppo della logica di business di una applicazione e della sua interfaccia.
Una delle politiche dell'azienda era quella di separare la gestione dei dati e la loro memorizzazione lato Backend in modo tale che la parte Frontend sviluppata con il framework Javascript AngularJS si interfacciasse con i dati servendosi solo di API REST.
Data il numero consistente di Web Application sviluppate e il mercato di applicazioni Mobile sempre in crescita, sono stato incaricato dall'azienda di ricercare dei metodi e delle tecnologie che consentissero di portare il lavoro già fatto per le Web Application su dispositivo mobile, in modo tale che l'azienda avesse nuovi servizi da offrire.\\
Tutte le applicazioni sviluppate fino ad allora erano già Responsive Web Application, in azienda si volevano aggiungere funzionalità caratteristiche dei dispositivi mobili tramite l'utilizzo di tecnologie web.\\

Un primo punto di riferimento come tecnologia Web è stato AgnularJS, framework già utilizzato dall'azienda, se fosse stato scelto un altro framework si sarebbe dovuto riscrivere tutto il codice delle Web Application già sviluppate fino a quel punto. A questo punto  si trattava di scegliere le corrette tecnologie per includere al meglio il lavoro già svolto, in particolare un Wrapper che avrebbe consentito un buon sviluppo dell'applicazione partendo da tecnologie web, senza influire su eventuali spese aziendali. 

Per quanto riguarda gli strumenti di sviluppo utilizzati la scelta rimane allo sviluppatore, nel mio caso ho preferito elencarne alcuni secondo me importanti utilizzati all'interno dell'azienda e scoperti durante l'attività di ricerca.

\section{Le Tecnologie Web utilizzate}
Il riferimento per la scelta di tecnologie web è stato il framework AngularJS, il quale è utilizzato a sua volta all'interno di altri framework, come ad esempio Ionic che fornisce degli strumenti per la creazione di interfacce utente. Come Wrapper ho scelto Cordova, in quanto oltre ad essere un progetto open-source fornisce delle API per le funzionalità del dispositivo in linguaggio Javascript. Inoltre esiste un'ultima libreria che richiama le funzionalità di Cordova utilizzando il framwork AngularJS, il che viene molto comodo per il set di tecnologie scelto.

Il framework Ionic per la creazione dell'interfaccia utente è composto oltre da AngularJS da altre tecnologie come un \emph{CSS Preprocessor} che verrà spiegato prima di introdurre nel dettaglio le tencnologie introdotte precedentemente.

\subsection{CSS Preprocessor}

Nei Web Framework che forniscono strumenti per la definizione di interfacce utente un componente che si trova molto spesso e il \emph{CSS Preporcessor} ovvero un preprocessore di fogli di stile.

\emph{In informatica, un preprocessore o precompilatore è un programma (o una porzione di programma) che effettua sostituzioni testuali sul codice sorgente di un programma, ovvero la precompilazione. I più comuni tipi di sostituzioni sono l'espansione di macro, l'inclusione di altri file, e la compilazione condizionale (vedi conditional compilation in inglese). Tipicamente, il preprocessore viene lanciato nel processo di compilazione di un software, e il file risultante verrà preso in input da un compilatore.}
\hspace*{\fill}\cite{wiki:preprocessor} 

\begin{figure}[htbp]
  \centering
    \includegraphics[scale=0.25]{Figures/sass-logo.png} 
    \includegraphics[scale=0.75]{Figures/less-logo.png} 
    \rule{35em}{0.5pt}
  \caption[Css Preprocessors]{\textbf{S}intatically \textbf{A}wesome \textbf{S}tyle\textbf{S}heet e \textbf{LESS}}
  \label{fig:CSS Preprocessors}
\end{figure}


Essendo CSS un linguaggio fortemente dichiarativo basato sui markup HTML, fa si che i fogli di stile per interfacce utente diventino molto lunghi e verbosi data la complessità. E di conseguenza la personalizzazione da parte dello sviluppatore che andrà a utilizzare il framework diventa molto difficile.
I CSS preprocessor mettono a disposizione un set di operazioni chiamate MACRO che durante la compilazione verranno sostituite con il linguaggio CSS prorpio. Queste MACRO consentono ad esempio di fare utilizzo di variabili, funzioni, tag parametrici, ereditarietà dei tag, pattern matching, namespaces.

Queste sono solo alcune delle opzioni messe a disposizione dei CSS preprocessors dipende dalle sviluppatore scegliere quello secondo lui più adatto in quanto sul mercato ne esistono diversi, i più famosi e utilizzati sono \textbf{SASS}(\textbf{S}intatically \textbf{A}wesome \textbf{S}tyle\textbf{S}heet) e \textbf{LESS}(write \textbf{LESS} do more) \ref{fig:CSS Preprocessors}.

\subsection{AngularJS}
\label{sec:angularjs}
\begin{wrapfigure}{r}{0.40\textwidth}
  \vspace{-65pt}
  \begin{center}
    \includegraphics[scale=0.40]{Figures/angular-logo.png}
  \end{center}
  \vspace{-10pt}
  \caption{\\AngularJS framework logo}
  \label{fig:AngularJS}
  \vspace{10pt}
\end{wrapfigure}

\paragraph*{Definizione}
AngularJS è un framework Javascript che segue il pattern MVC(\ref{subsec:mvc}) ideato da \emph{Minsko Hevery}(Google) che estende il linguaggio HTML in un formato più espressivo e leggibile. È caratterizzato da un approccio dichiarativo alla programmazione ed è stato pensato per separare la logica di business di una applicazione dalla sua presentazione dei dati, infatti sono presenti tag HTML espliciti come \emph{ng-view} e \emph{ng-model} che consentono di sincronizzare i dati del modello con la vista indipendentemente dalla loro logica. AngularJS è stato pensato esplicitamente per lo sviluppo di web application è presenta una forte modularità dei suoi componenti, in modo da renderli indipendenti e testabili, rispetta infatti i principi \emph{SOLID} della programmazione orientata agli oggetti.
Ecco le caratteristiche principali di questo framework:

\begin{description}

\item[View] la presentazione dei dati in AngularJS viene fatta tramite un sistema di viste con l'utilizzo di pagine HTML. Ad ogni vista possono essere associati più modelli di dati da presentare ed inoltre tramite un meccanismo di \emph{routing} e possibile determinare una struttura, anche gerarchica di più viste. Un componente 



\item[Data Binding] Il Data Binding in AngularJS è la sincronizzazione automatica dei dati tra modello e vista. In modo in cui AngularJS implementa il data bindign consente di trattare il modello come SSOT(\cite{wiki:SSOT}). La vista è la proiezione del modello in ogni momento, quando il modello cambia la vista riflette il cambiamento e viceversa. 
La maggior parte dei sistemi di templating sincronizzano i dati in una sola direzione: si fondono componenti del template e modello insieme in una vista. Quando si verifica la fusione, le modifiche al modello o sezioni correlate della vista vengono NON si riflettono automaticamente nella vista. Peggio ancora, le eventuali modifiche che l'utente fa nella vista non si riflettono nel modello. Ciò significa che lo sviluppatore deve scrivere del codice apposito che sincronizza costantemente la vista con il modello e il modello con la vista.

\begin{figure}[htbp]
  \centering
    \includegraphics[scale=0.5]{Figures/one-way-data-binding.png} 
    \includegraphics[scale=0.5]{Figures/two-way-data-binding.png} 
    \rule{35em}{0.5pt}
  \caption[Data Bindings]{Come è strutturato un classico data binding, e come invece è fatto in AngularJS}
  \label{fig:Data Binding}
\end{figure}

In particolare come si vede nell'esempio \ref{lst:directives-example} il binding dalla vista al modello è effettuato tramite la direttiva \emph{ng-model = "nome-del-modello"}, mentre dal modello alla vista si utilizza la sintassi \emph{ \{\{nome-del-modello\}\} }.

Il systema dei templates di AngularJS funziona in modo differente. In primo luogo il modello (che è l'HTML non compilato insieme a  markup o direttive supplementari) viene compilato sul browser. Il passo di compilazione produce una live view(vista). Eventuali modifiche alla vista si riflettono immediatamente nel modello, e le eventuali modifiche nel modello vengono propagate alla vista. Il modello è il SSOT per lo stato dell'applicazione, semplificando notevolmente il modello di programmazione per lo sviluppatore. Si può pensare di vista semplicemente come una proiezione istantanea del modello.

Poiché la vista è solo una proiezione del modello, il controller è completamente separato dal punto di vista e completamente allo scuro di essa. Questo rende i test dell'applicazione molto semplici, in quanto è facile testare il controller indipendentemente dalla vista e dalla relativa dipendenza dal DOM / browser web.

\item[Controller] i controller in AngularJS hanno il compito di gestire la logica di una determinata sezione dell'applicazione. Quando un controller viene dichiarato su una parte del DOM tramite la direttiva \emph{ng-controller} come nell'esempio \ref{lst:newController} AngularJS crea un nuovo oggetto Javascript associandogli un nuovo scope che potrà essere inserito all'interno del controller tramite la dependency injection. 

\begin{lstlisting}[caption={Associazione tra un elemento del DOM e un controller}, label={lst:newController}]
	<div id="header" ng-controller = "HeaderController"></div>
\end{lstlisting}
In generale ci sono alcune regole da seguire per la creazione dei controller, le quali non sono obbligatorie ma sono considerate come si dice in gergo \emph{Best Practices}:
I controller devono essere usati per:
\begin{itemize}
\item Configurare lo stato iniziale dello scope.
\item Aggiungere comportamento allo scope(funzioni, modelli, oggetti)
\end{itemize}
Mentre i controller non devono essere usati per:
\begin{itemize}
\item Manipolare elementi del DOM
\item Formattare input e output
\item Condividere codice tra i vari controller.
\item Gestire il ciclo di vita degli altri componenti(creazione di nuove istanze)
\end{itemize}

\item[Dependency Injection] per una trattazione generale dell'argomento rimandiamo all'appendice \ref{app:DepInj}. AngularJS ha già al suo interno un meccanismo che gestisce la Dependency Injection. Il principale scopo per cui AngularJS è stato dotato di questa caratteristica è per avere la possibilità di suddividere in moduli separati l'applicazione dove ognuno di essi può essere iniettato all'interno degli altri e vice versa. Un esempio moto semplice di Dependency Injection in AngularJS è all'atto della creazione dell'applicazione. Nell'esempio \ref{lst:appCreation} il metodo \textit{angular.module()} prende due argomenti: il primo è il nome del modulo che si vuole creare, mentre il secondo è un array con tutti i moduli di cui è composto la nostra applicazione. Viene creato quindi un riferimento ai moduli inclusi e non un istanza diretta.  
\begin{lstlisting}[caption = {Creazione di una applicazione in AngularJS con le relative dipendenze}, 
				   label = {lst:appCreation}]
	var testApp = angular.module("testApp",['ngRoute','customModule']);
\end{lstlisting}

Oltre ai moduli AngularJS da la possibilità di usare la propietà della Dependency Injection sui tipi base forniti dal linguaggio, ovvero:
\begin{itemize}
\item Value
\item Factory
\item Service
\item Provider
\item Constant
\end{itemize}
Un esempio di Dependency Injection di questi tipi avviene molto frequentemente nelle applicazioni all'interno dei controller (\ref{lst:controllerExample})

\begin{lstlisting}[caption = {Un esempio di creazione di un modulo e la sua inclusione all'interno di un altro}, 
				   label = {lst:controllerExample}]

angular.module("CustomModule",[])
.service("CustomService",function(){
	this.customMethod = function(value){
		return value + " from customMethod in CustomService";	
	}
});

angular.module("testApp",[
	'CustomModule'
]).controller("HomeController", function(CustomService){
	CustomService.customMethod("Marco");
});


\end{lstlisting}

\item[Service] si è visto come il meccanismo di Dependency Injection possa rendere disponibile all'interno dell'applicazione tutti i componenti forniti da un specifico modulo. Fatta eccezione per i \emph{service} ogni volta che si richiama un componente tramite Dependency Injection dal riferimento viene creata una nuova istanza della classe. I service invece sfruttano quello che è chiamato in Javascript il \emph{Singleton Object}, ovvero, l'istanza di un oggetto di tipo service avviene soltanto una volta, e il riferimento all'interno dell'applicazione è univoco verso lo stesso oggetto(figura \ref{fig:AngularJS-Singleton}). Inoltre soltanto quando il service dipende dall'applicazione viene creata l'istanza dell'oggetto(\emph{Lazy Initialization}).

\begin{figure}[htbp]
  \centering
    \includegraphics[scale=0.75]{Figures/angularjs-service-singleton-diagram.png}  
    \rule{35em}{0.5pt}
  \caption[AngularJS Singleton]{Schema di come è strutturato un service all'interno di AngularJS}
  \label{fig:AngularJS-Singleton}
\end{figure}

I service possono essere creati dallo sviluppatore oppure AngularJS ne mette a disposizione già alcuni, come ad esempio \emph{\$http} che è uno dei più usati per lo scambio dei dati attraverso l'omonimo protocollo. Altro uso dei service può essere quello dello scambio dei dati attraverso i controller, genericamente in una applicazione che si interfaccia con dei servizi backend e buona norma associare ad ogni servizio corrispettivo un service di AngularJS.

\item[Provider/Factory/Service] una trattazione separata di queste tre caratteristiche di AngularJS potrebbe risultare difficile da comprendere. Avendo spiegato cosa è un service la trattazione prosegue su altri due componenti strettamente correlati: i Factory e i Provider.
Tra questi tre componenti esiste una specie di gerarchia : i \textit{service} sono degli oggetti singleton creati tramite una \textit{factory}. Le \textit{factory} sono funzioni che a sua volta sono create tramite un \textit{provider}. I \textit{provider} sono dei costruttori che hanno a disposizione un metodo \emph{\$get} il quale contiene la \emph{service factory} che ritorna l'istanza del service.

In questo modo AngularJS si garantisce una forte modularizzazione dei componenti, e la ricerca dei corretti riferimenti da parte della Dependency Injection. Inoltre tramite il provider è possibile configurare, se previsto, i servizi dell'applicazione scrivendo un opportuno codice parametrico.

\item[Directives] una delle caratteristiche più rilevanti di AnagularJS è sicuramente quella di poter creare dei tag HTML personalizzati, oltre a quelli già previsti dal framework. Questi tag speciali sono chiamati directives o direttive. AngularJS si serve delle direttive per poter strutturare l'applicazione sulla vista HTML, ovvero ci sono dei tag speciali previsti dal framework che definiscono il nome dell'applicazione(\textit{ng-app}), i controller da utilizzare(\textit{ng-controller}), i modelli di riferimento(\textit{ng-model}) e il contenitore dove processare le viste(\textit{ng-view}) come nell'esempio \ref{lst:directives-example}:
\begin{lstlisting}[language=html,caption={Un esempio delle direttive standard di AngularJS},
				   label={lst:directives-example}]
 <html ng-app = "myApp">
   <head></head>
   <body>
     <div ng-controller = "InfoController">
       <input name = "inputFirstName" ng-model = "user.firstName">
       <input name = "inputSecondName" ng-model = "user.secondName">
       <div class = "showInfo">
	     Hello my name is {{user.firstName}} {{user.secondName}}			
       </div>
     </div>
   </body>
 </html>
\end{lstlisting}

Inoltre possiamo definire direttive personalizzate alle quali possiamo associare un relativo comportamento(\ref{lst:custom-directive}). Una cosa che è concessa nelle direttive e non nelle altre strutture di AngularJS è la manipolazione del DOM, solo al loro interno è possibile scrivere codice che interagisca direttamente con gli elementi della vista.
\begin{lstlisting}[language=html,caption={Un esempio di direttiva personalizzata},
				   label={lst:custom-directive}]
 angular.module("myApp")
 .directive("myPersonalTag",function(){
	return{
		link: function(scope, element, attrs){
			//directive main istructions		
		}	
	} 
 });
\end{lstlisting}

Una nota di sintassi particolare per le direttive riguarda il loro nome, come osserviamo il nome delle direttive nell'esempio \ref{lst:directives-example} è separato dal trattino alto(\emph{dash}) mentre nella definizione tramite codice AngularJS è scritta in \emph{camelCase}. Questa è un convenzione che il framework adotta per evitare errori di sintassi all'interno del codice da parte del parser.
Oltre alle caratteristiche principali con le direttive si hanno a disposizione molte più opzioni. Si rimanda l'approfondimento qui : \cite{angularjs:directives} per un trattazione più approfondita.

\end{description} 



\subsection{Ionic}

\begin{wrapfigure}{r}{0.40\textwidth}
  \vspace{-65pt}
  \begin{center}
    \includegraphics[scale=0.35]{Figures/ionic-logo.png}
  \end{center}
  \vspace{-10pt}
  \caption{Ionic Framework Logo}
  \label{fig:IONIC}
  \vspace{5pt}
\end{wrapfigure}

IONIC fa parte della famiglia degli UI Framework per creazione di interfacce utente per dispositivi mobili e applicazioni ibride e si serve delle tecnologie web AngularJS, Sass e HTML5.
Il lavoro da svolgere per chi vuole utilizzare questo tipo di framework e quello di scegliere i vari componenti messi a disposizione e di comporli per creare l'applicazione finale. Generalmente si parte da un template messo a disposizione dal framework e si compone l'applicazione. La modularità dei componenti di IONIC è data dal sistema di direttive di AngularJS, tutti i componenti sono sviluppati in direttive separate e come si può notare tutti i rispettivi tag HTML iniziano con il prefisso \textit{ion} o \textit{ionic}. 
La caratterizzazione di un framework di questo tipo dipende dal suo stile e design e sta allo sviluppatore(o  grafico) decidere quale in questo caso il più bello per l'applicazione. IONIC inoltre mette a disposizioni diverse caratteristiche che possono influenzare la sua scelta:
\begin{description}
\item[CSS Components]
Sono dei componenti statici creati tramite HTML e CSS come bottoni, barre di navigazione, liste, tabelle che possono essere assemblati tra di loro come i componenti di una pagina web. I CSS di IONIC mettono a disposizione classi che possono cambiarne forma, dimensione e colore che a loro volta possono essere combinate.
Per personalizzazioni più avanzate e possibile seguire una guida messa a disposizione dal framework che spiega come modificare i file di Sass e che caratteristiche si va a cambiare(come ad esempio i colori standard).
\item[Javascript Components]
Al fine di offrire una esperienza di una applicazione mobile all'utente, IONIC offre delle estensioni in ANgularJS che ricalcano quelle che sono le operazioni e le interfacce più comuni sui i dispositivi mobili. Ispirato ai sistemi iOS e Android questo framework mette a disposizione componenti come gestori di eventi, paginazione dei contenuti, popup di sistema, touch gestures, menu laterali, scorrimento di pagine il tutto nello stile di una applicazione mobile vera e prorpia.
\item[Ionicons]
IONIC prevede un set di icone standard che possono essere utilizzate all'interno dei componenti e personalizzate a proprio piacimento.

\end{description} 
\section{Il Wrapper Framework}
Come spiegato nella sezione \ref{sec:appAndFramework} per lo sviluppo di applicazioni ibirde si necessita di un framework che possa in qualche modo tradurre il linguaggio originale in quello della specifica piattaforma.
Nel caso qui studiato si ha bisogno di un framework che possa ospitare tecnologie web e che abbia un interfaccia verso le funzionalità del dispositivo. Si ribadisce che non tutti i framework possono essere usati su tutte le piattaforme, bisogna scegliere con accortezza di quale servirsi.
Data la mia formazione come sviluppatore web presso l'azienda BigThink SRL ho scelto di utilizzare il framework \emph{Cordova} per i seguenti motivi:
\begin{itemize}
\item E' un framework che si adatta a sviluppatori web che vogliono portare le proprie applicazioni su dispositivi mobili, in quanto fornisce le varie API per le funzionalità del dispositivo in linguaggio Javascript.
\item E' open-source quindi costi di licenza nulli per l'azienda e per lo sviluppatore ed inoltre e seguito da una community popolata e attiva.
\item Supporta 16 piattaforme diverse con oltre 20 plugin per interagire con il dispositivo, assieme ad altre librerie per la creazione di plugin personalizzati.
\item Si integra al meglio con AngularJS grazie ad una libreria chiamata \emph{ng-cordova}(\ref{sec:ngCordova}).
\end{itemize}

\subsection{Cordova/Phonegap}

\begin{wrapfigure}{r}{0.40\textwidth}
  \vspace{-65pt}
  \begin{center}
    \includegraphics[scale=0.35]{Figures/cordova-logo.png}
  \end{center}
  \vspace{-10pt}
  \caption{\\Cordova Framework Logo}
  \label{fig:Cordova}
  \vspace{-30pt}
\end{wrapfigure}


Per chi magari è nuovo nel settore delle applicazioni multi-piattaforma, o per chi ci è entrato da poco 	avrà fatto sicuramente confusione tra queste due nomenclature \texttt{Cordova} e \texttt{Phonegap}, ecco quindi una delucidazione sul fatto.

\subsubsection{Storia}
Phonegap è stato creato nel 2009 da una startup chiamata \emph{Nitobi} come progetto open-source. Si proponeva di fornire un metodo per l'accesso alle funzionalità native del dispositivo tramite il meccanismo di wrapping che è stato discusso nel capitolo precedente a proposito dei framework. L'obiettivo di questa piattaforma era appunto quello di poter creare delle applicazioni che potessero essere usate nei dispositivi mobili, tramite l'utilizzo di tecnologie web come HTML5, CSS e Javascript, ma con ancora la possibilità di accedere alle funzionalità native del dispositivo.\\
Nel 2011 \emph{Adobe} ha acquisito la startup Nitobi assieme ai diritti di Phonegap, e il codice open-source della piattaforma è stato donato all'\emph{Apache Software Foundation} con il nome di \texttt{Cordova}

\subsubsection{Differenze}
La vera differenza tra \texttt{Cordova} e \texttt{Phonegap}, viene descritta da \emph{Adobe} analogamente come la differenza tra \texttt{Blink}\footnote{Blink è la web browser engine di Google Chrome\cite{wiki:blink}} e \emph{Google Chrome}. Ovvero \emph{Cordova} e il cuore della piattaforma mentre \emph{Phonegap} aggiunge a \emph{Cordova} delle funzionalità proprietarie di \emph{Adobe}.\\
Personalmente ho scelto di utilizzare \emph{Cordova} per essere libero da qualsiasi vincolo proprietario.

\subsubsection{Cordova Core}
Cordova quindi offre una serie di potenti API in linguaggio Javascript per poter accedere alle funzionalità native del dispositivo. In difesa dello sviluppo nativo alcuni programmatori accusano \emph{Cordova} di non possedere tutte le possibilità di accesso a basso livello che invece si avrebbero. \emph{Corodova} è una realtà open-source e in quanto tale si è evoluta nel tempo offrendo sempre più funzionalità che hanno chiuso i divario che si credeva esservi tra questi due tipi di approcci.

\subsection{ngCordova}
\label{sec:ngCordova}
\begin{wrapfigure}{r}{0.40\textwidth}
  \vspace{-65pt}
  \begin{center}
    \includegraphics[scale=0.35]{Figures/ngcordova-logo.png}
  \end{center}
  \vspace{-10pt}
  \caption{\\ngCordova Logo}
  \label{fig:ngCordova}
  \vspace{0pt}
\end{wrapfigure}

Il perché in questa tesi si parli di \emph{Cordova} e \emph{AngularJS} è dato dall'esistenza di \texttt{ngCordova}. Questa libreria nasce da una idea di Paolo Bernasconi e Max Lynch che hanno avuto l'idea di unire la l'efficenza e la potenza di \emph{AngularJS} con la versatilità di \emph{Cordova}. Ne è nato un framework per lo sviluppo di applicazioni ibride direttamente collegato alle funzionalità del dispositivo gestibile tramite il codice efficiente di \emph{AngularJS}.\\

\section{Strumenti di sviluppo}

Il consistente numero di tecnologie che si possono utilizzare per lo sviluppo ibrido viene spesso accompagnato da strumenti che consentono di creare un ambiente progettuale in cui si ha a disposizione tutto il necessario per poter iniziare a sviluppare. La scelta di determinati strumenti piuttosto che altri è riservata allo sviluppatore finale, personalmente mostrerò come ho deciso di organizzare un progetto di esempio.

\subsection{Package Manager}

Avendo a disposizione tutto il mondo delle tecnologie web, può risultare utile e molto produttivo inserire librerie all'interno del nostro progetto. Per le applicazioni web in generale e anche in quelle ibride si può disporre di un package manager che facilmente includere nuove librerie all'interno del progetto.\\

\textbf{Bower} è un package manager tipicamente usato per librerie Javascript. Generalmente è possibile reperire ogni libreria disponibile su Github. Tramite il file \emph{bower.json} possiamo specificare le dipendenze del progetto e dinamicamente aggiornare la lista delle librerie installate. Inoltre se stiamo lavorando con una struttura di cartelle specifica, come ne mio caso, possiamo specificare la posizione di dove verranno scaricate le librerie tramite il file \emph{.bowerrc}. 

\begin{lstlisting}[language=html,caption={Una tipica configurazione del file .bowerrc},
				   label={lst:bowerrc}]
	{
		"directory" : "js/vendor"
	}
\end{lstlisting}

\begin{lstlisting}[language=html,caption={Una tipica configurazione del file bower.json},
				   label={lst:bowerjson}]
{
  "name": "blog.marcopredari.it",
  "version": "0.0.0",
  "authors": [
    "predorock <predorock@gmail.com>"
  ],
  "description": "A simple blog with angularJS",
  "main": "index.html",
  "license": "MIT",
  "homepage": "blog.marcopredari.it",
  "private": true,
  "ignore": [
    "**/.*",
    "node_modules",
    "bower_components",
    "test",
    "tests"
  ],
  "dependencies": {
    "angular-sanitize": "~1.3.10",
    "angular": "~1.3.10"
  }
}

\end{lstlisting}

\subsection{Task Runner}

\begin{wrapfigure}{r}{0.40\textwidth}
  \vspace{-65pt}
  \begin{center}
    \includegraphics[scale=0.4]{Figures/grunt-logo.png}
	\includegraphics[scale=0.3]{Figures/gulp-logo.png}  
  \end{center}
  \vspace{-10pt}{
	"directory" : "js/vendor"
}

  \caption{Loghi di Grunt e Gulp}
  \label{fig:task runner}
  \vspace{0pt}
\end{wrapfigure}

La divisione logica in moduli di una applicazione porta i programmatori a separare in file diversi l'applicazione in fase di sviluppo. Per poter ottenere una versione in fase di produzione occorre assemblare tutte le parti del progetto e se necessario eseguire dei test.
Il ruolo dei task-runner è quello di eseguire determinate operazioni per la messa in produzione dell'applicazione, come la concatenazione dei file, controllo della sintassi, test sui moduli e lo spostamento del progetto nella directory finale.

\textbf{Grunt} e \textbf{Gulp} sono due esempi di \emph{task-runner} in linguaggio Javascript(NodeJs). Una caratteristica che li distingue e la loro modularità, in quanto in base alle esigenze dell'applicazione si possono scaricare i moduli dedicati in base ai processi richiesti per la messa in produzione. Successivamente si deve scrivere un file(\textit{grunt.js} o \textit{gulp.js}) dove si indicano tutte le istruzioni per la messa in produzione. Ho voluto nominarli entrambi nella mia tesi in quanto il primo l'ho usato durante la mia esperienza di tirocinio, il secondo invece è usato per lo sviluppo del framework Ionic.



\section{SDK}
Un \texttt{Software Developement Kit} in generale è un insieme di strumenti per lo sviluppo e la documentazione del software\cite{wiki:sdk}. Questi strumenti vengono rilasciati dalla casa produttrice di una certa piattaforma come librerie di riferimento per lo sviluppo di software specifico di essa. La loro distribuzione avviene in uno specifico linguaggio a seconda della piattaforma ed è sempre affiancata da una documentazione molto accurata. 
Per lo sviluppo di applicazioni ibride avremo bisogno di ciascuna \emph{SDK} per ogni sistema operativo sul quale vorremo la nostra applicazione; ad esempio se volessimo la nostra applicazione per \emph{iOS} e \emph{Android} dovremmo scaricare entrambe le \emph{SDK}(scritte rispettivamente in C++/Swift e Java) indicando dove si trovano all'interno del notro computer.

\section{Creazione di una applicazione}

Dopo aver presentato tutte le tecnologie e gli strumenti per lo sviluppo di applicazioni ibride si mostrerà un processo di sviluppo molto minimale con l'obiettivo di mostrare dove e come possono essere utili gli strumenti visti in  precedenza.

\subsection{Ambiente di sviluppo}

L'ambiente di sviluppo di una applicazione ibrida dipende direttamente dal framework che si andrà a utilizzare per la distribuzione su più piattaforme, in questo caso Cordova. Alcuni IDE predispongono già un tipo di progetto basato su cordova e tecnologie web, come ad esempio NetBeans e IntelliJ IDEA. Altrimenti Cordova e Ionic predispongono già un client da linea di comando per inizializzare nuovi progetti.

Tutte queste soluzioni per la creazione di nuovi progetti includono un template di partenza con lo scopo di dare una struttura minimale ai file del progetto. Nel mio caso ho scelto di usare l'IDE NetBeans in quanto risulta più chiaro e semplice il processo di sviluppo.


