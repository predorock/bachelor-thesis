\lhead{\emph{Capitolo 3}}
\chapter{La soluzione proposta}
In questo capitolo discuteremo la soluzione intrapresa per lo sviluppo veloce di applicazioni mobile multi-piattaforma con le tecnologie scelte e le scelte progettuali intraprese. 
\section{Le Tecnologie Web}
Le tecnologie web sono sempre più utilizzate per lo sviluppo di applicazioni mobile multi-piattaforma, molti framework come \texttt{Ionic}, \texttt{Foundation}, \texttt{Lungo} utilizzano già HTML5, CSS, Javascript per le loro librerie, ottimizzate per dispositivi mobili.\\
In particolare questi framewrok mettono a disposizione una serie di componenti già pronti come ad esempio bottoni, menù laterali, form, liste, tabelle, icone, etc\dots e consentono di abbinarli tra di loro come meglio si ritene, con la possibilità di personalizzarli ulteriormente.\\
\subsection{SASS}
Nei framework che usano tecnologie web,e anche nelle pagine web, i fogli di stile hanno lo scopo di definire design, forme e colori dei componenti HTML. Nel caso dei framework però, i fogli di stile possono diventare molto complessi diventando lunghi e verbosi e difficili da modificare e/o ri-utilizzare.\\
Esistono degli strumenti che permettono di strutturare al meglio i fogli di stile preservandone tutte le qualità se non aggiungendo ulteriori potenzialità.\\
Uno di questi è \emph{SASS(Syntatically Awesome Stylesheet)}; si tratta di una estensione del linguaggio \emph{CSS} che va aggiungere strumenti come: direttive di pre-processore, variabili, annidamento di classi e id, possibilità di dividere in più file parziali e a sua volta includerne altri all'interno, ereditarietà delle classi, mixins ovvero classi parametrizzate e infine operatori matematici.\\
Per usare \emph{SASS} dobbiamo creare prima dei documenti con l'estensione \emph{.scss} che una volta compilati daranno origine al foglio di stile \emph{CSS}(o a più fogli di stile).
Esistono altri strumenti anche migliori di questo per l'estensione dei fogli di stile, ma successivamente vedremo che il framework che ho utilizzato per la struttura delle mie applicazioni fa uso di questa tecnologia. 
\subsection{AngularJS}
AngularJS è un framework Javascript ideato da \emph{Google} per rendere dinamiche le pagine web. E' stato pensato con un modello di sviluppo \emph{Model View Controlled} quindi l'applicazione che si andrà a sviluppare avrà un serie di \emph{view} dinamiche, a loro volta gestite da entità chiamate \emph{controller}.\\
Una delle caratteristiche che lo rende un framework molto potente da usare è sicuramente il \texttt{Data Bindign}. Il Data Binding è un modo per aggiornare dati in una vista ogni volta che questo cambia senza bisogno di aggiornare la pagina o di modificare il DOM. La cosa è reciproca, se i dati di modificano nella \emph{view} (come potrebbe accadere nel caso di un form) questi sono automaticamente aggiornati dinamicamente all'interno della nostra applicazione.\\
Abbiamo parlato prima di \emph{controller}, sostanzialmente sono delle entità che controllano il comportamento degli elementi della vista. All'interno dei \emph{controller} possiamo definirci tutti i metodi e le funzioni che desideriamo inserire all'interno della vista.\\
AngularJS consente inoltre di creare i propri tag HTML personalizzati, con la possibilità di aggiungere nuovi attributi opzionali e non. Il punto di forza delle direttive e la loro riusabilità, in quanto , se scritte bene, diventano tag e/o attributi riutilizzabili come del comune codice HTML.\\
Un altro punto di forza è sicuramente la \texttt{Dependency Injection} (verrà spiegata in dettaglio nei capitoli successivi). Questa caratteristica in AngularJS consiste nel descrivere come è connessa la mia applicazione, non abbiamo bisogno di un metodo \emph{main()}, come ad esempio si usa in \emph{Java}, ma possiamo decidere a priori di quali moduli è composta la nostra applicazione.
\begin{center}
\emph{This means that any component which does not fit your needs can easily be replaced.} 
\end{center}
Come abbiamo appena detto, una applicazione in AngularJS può essere facilmente divisa in moduli. Questa caratteristica garantisce una riduzione della complessità del codice che si andrebbe a scrivere, inoltre come il suo inventore Minsko Hevery ripete nella maggior parte delle sue conferenze, AngularJS è stato pensato per essere facilmente testabile.

\subsection{Ionic}
Ionic offre componenti e librerie pensati per uno sviluppo ibrido dell'applicazione, inoltre è stato sviluppato riducendo al minimo la manipolazione del DOM\footnote{Il Document Object Model (spesso abbreviato come DOM), letteralmente modello a oggetti del documento, è una forma di rappresentazione dei documenti strutturati come modello orientato agli oggetti.\cite{wiki:dom} gli oggetti delle pagine web, ad esempio con delle animazioni, introduciamo della computazione aggiuntiva al nostro browser che può rallentarne le prestazioni} garantendo performance molto competitive.\\
I componenti di Ionic vengono ovviamente strutturati tramite HTML5, aggiungendo classi css specifiche del framework. Inoltre 
Ionic fornisce uno strumento molto interessante da linea di comando che permette di scaricare diversi modelli di applicazione già pronti in modo da non dover tutte le volte configurare da capo la nostra applicazione con il framework. Inoltre ci predispone i file in una maniera logica ben precisa cosicché se volessimo in un futuro aggiungere codice e/o altre librerie possiamo farlo con molta facilità.
I componenti non sono altro che elementi del linguaggio HTML, vengono forniti con una serie di classi CSS caratteristiche del framework, pensate in modo da essere componibili tra di loro. Ionic fornisce inoltre dei tag propri del framework che possono includere elementi più complessi come ad esempio menù laterali.
Il cuore di Ionic e tutte le sue funzionlità sono state sviluppate in AngularJS il che rende questo framework ancora più versatile e potente. Inoltre tutti il foglio di stile che include Ionic fa uso di SASS e ci da la possibilità di personalizzare colori e forme dei componenti semplicemente ricompilando i file \emph{.scss}.
\section{Cordova/Phonegap}
Per chi magari è nuovo nel settore delle applicazioni multi-piattaforma, o per chi ci è entrato da poco avrà fatto sicuramente confusione tra queste due nomenclature \texttt{Cordova} e \texttt{Phonegap}, ecco quindi una delucidazione sul fatto.
\subsection{Storia}
Phonegap è stato creato nel 2009 da una startup chiamata \emph{Nitobi} come progetto open-source. Si proponeva di fornire un metodo per l'accesso alle funzionalità native del dispositivo tramite il meccanismo di wrapping che è stato discusso nel capitolo precedente a proposito dei framework. L'obiettivo di questa piattaforma era appunto quello di poter creare delle applicazioni che potessero essere usate nei dispositivi mobili, tramite l'utilizzo di tecnologie web come HTML5, CSS e Javascript, ma con ancora la possibilità di accedere alle funzionalità native del dispositivo.\\
Nel 2011 \emph{Adobe} ha acquisito la startup Nitobi assieme ai diritti di Phonegap, e il codice open-source della piattaforma è stato donato all'\emph{Apache Software Foundation} con il nome di \texttt{Cordova}
\subsection{Differenze}
La vera differenza tra \texttt{Cordova} e \texttt{Phonegap}, viene descritta da \emph{Adobe} analogamente come la differenza tra \texttt{Blink}\footnote{Blink è la web browser engine di Google Chrome\cite{wiki:blink}} e \emph{Google Chrome}. Ovvero \emph{Cordova} e il cuore della piattaforma mentre \emph{Phonegap} aggiunge a \emph{Cordova} delle funzionalità proprietarie di \emph{Adobe}.\\
Personalmente ho scelto di utilizzare \emph{Cordova} per essere libero da qualsiasi vincolo proprietario.
\subsection{Cordova Core}
Cordova quindi offre una serie di potenti API in linguaggio Javascript per poter accedere alle funzionalità native del dispositivo. In difesa dello sviluppo nativo alcuni programmatori accusano \emph{Cordova} di non possedere tutte le possibilità di accesso a basso livello che invece si avrebbero. \emph{Corodova} è una realtà open-source e in quanto tale si è evoluta nel tempo offrendo sempre più funzionalità che hanno chiuso i divario che si credeva esservi tra questi due tipi di approcci.\\
Infine per quanto riguarda lo sviluppo dei plugin verso il futuro, la comunità open-source di \emph{Cordova} sta spronando gli sviluppatori a creare nuove funzionalità sempre più generiche, in modo tale che con l'evolversi delle tecnologie, e soprattutto dei browser web, siano sempre compatibili.
\subsection{ngCordova}
Il perché in questa tesi si parli di \emph{Cordova} e \emph{AngularJS} è dato dall'esistenza di \texttt{ngCordova}. Questa libreria nasce da una idea di Paolo Bernasconi e Max Lynch che hanno avuto l'idea(geniale) di unire la l'efficenza e la potenza di \emph{AngularJS} con la versatilità di \emph{Cordova}. Ne è nato un framework per lo sviluppo di applicazioni ibride direttamente collegato alle funzionalità del dispositivo gestibile tramite il codice efficiente di \emph{AngularJS}.\\
Per chi vuole sviluppare applicazioni ibride multi piattaforma, questa libreria rende decisamente più rapido ed efficiente il processo di sviluppo.
\section{Un esempio di Sviluppo rapido}
\subsection{Il trio Magico}
La mia scelta delle tecnologie da utilizzare per lo sviluppo ibrido di applicazioni multi piattaforma si è incentrata soprattutto sull'efficienza e la compatibilità. Decidendo di utilizzare \texttt{AngularJS} + \texttt{Cordova} + \texttt{ngCordova} ottengo un ambiente di sviluppo rapido ed efficiente, in quanto tutti e tre i framework sono stati sviluppati per una stretta collaborazione, e allo stato dell'arte attuale delle tecnologie penso che sia una delle scelte migliori e rapide di sviluppo.
\subsection{IDE}
Ho scelto di usare una \emph{Integrated Develop Enviroment}(IDE) per lo sviluppo della mia applicazione in modo tale da tenere sotto controllo tutti i file del mio progetto e per poterli organizzare in una struttura di tipo modulare. 
Tra i diversi IDE disponibili ho scelto di usare \emph{NetBeans} in quanto può predisporre di un ambiente adatto allo sviluppo di applicazioni multi-piattaforma. In particolare è possibile partire da un modello di progetto basato su \emph{Cordova} oppure semplicemente in \emph{HTML5} ed inoltre è molto semplice configurare le SDK dedicate per il deploy sui vari sistemi operativi.
\subsubsection{Creazione}
Tramite NetBeans inizializziamo un nuovo progetto basato si Cordova.
-- Immagine nuovo progetto --\\
-- Immagine scelta del template --
In NetBeans non abbiamo il template fornito da Ionic, ma possiamo inizializzare tramite terminale il progetto e poi importarlo nell'IDE. Facendo questa operazione dobbiamo avere l'accortezza di aggiornare le impostazioni del progetto all'interno di NetBeans.
-- Immagine progetto --
Qui abbiamo i risultato del nostro progetto dal quale partire per lo sviluppo.
\subsubsection{Inclusione di Librerie esterne}
Nei progetti per applicazioni multi piattaforma che utilizzano tecnologie web può risultare utile includere delle librerie esterne(spesso in linguaggio Javascript), che con questo tipo di tecnologia, questa operazione risulta molto rapida e intuitiva. \\
Semplicemente come si agisce nei siti web, si inserisce uno script all'interno della pagina \emph{index.html} che va a includere il file della libreria desiderate.
\begin{lstlisting}[language=html]
	<script src = "lib/mylibrary/dist/mylibrary.min.js"></script>
\end{lstlisting}
Con NetBeans possiamo utilizzare in fase di configurazione e anche successivamente uno strumento che automaticamente include librerie da lui elencate, il quale è molto utile ma ovviamente non dispone di tutta la varietà presente in rete. uno strumento molto potente, usato dalla stragrande maggioranza degli sviluppatori web è \texttt{Bower}.
\paragraph{Bower} è un package manager, ci consente di organizzare al meglio le librerie all'interno del nostro progetto. Tramite il file \emph{bower.json} possiamo specificare tutti i dettagli del nostro progetto e dinamicamente aggiornare la lista delle librerie installate. Inoltre se stiamo lavorando con una struttura di cartelle specifica, come ne mio caso, possiamo specificare la posizione di dove verranno scaricate le librerie tramite il file \emph{.bowerrc}. In ambito web non esiste libreria che non possa essere scaricata con bower, sostanzialmente possiamo ottenere qualsiasi cosa presente su \emph{Github}.
-- Codice Bower.json --
-- Codice .bowerrc --
\subsubsection{Deploy}
L'operazione di \emph{Deploy} in italiano "schierare", nel nostro caso prende il significato di produrre una versione della nostra applicazione, che può essere finale oppure no. Nello sviluppo di applicazioni ibride multi piattaforma abbiamo a disposizione 3 opzioni per fare questa operazione.
\begin{description}
\item[Delploy sul Browser] Ovvero andiamo a vedere quella parte di applicazione che non necessita di essere sul dispositivo per poter funzionare. Sostanzialmente visualizziamo solo il livello delle tecnologie web, e lo possiamo correggere e/o visionare come se fosse un normale sito web. In questa modalità però non disponiamo ad esempio dell'interazione con le funzionalità native del dispositivo, si tratta di un modo rapido per avere una vista su quella che sarà l'interfaccia dell'applicazione.
\item[Simulazione] Ogni IDE consente un meccanismo di simulazione di un dispositivo sulla propria macchina. In questa modalità possiamo vedere realmente come sarà la nostra applicazione su un dispositivo, ma in realtà l'hardware di riferimento sarà quello della nostra macchina(il simulatore si occupa di mettere in comunicazione tutte le componenti). E' una modalità che si avvicina molto alla rappresentazione reale della nostra applicazione ma il processo di simulazione per un computer di fascia media comporta una attesa anche di minuti per visionare il risultato, e dato che dovremo ripetere questa operazione diverse volte perché può darsi che si debba correggere il codice(cosa molto frequente), diventa molto dispendioso attendere tutte le volte così tanto tempo.
\item[Installazione su Dispositivo] Quasi tutti i sistemi operativi ad eccezione di iOS, concedono di installare applicazioni direttamente da PC. Nel caso di Android che ho preso in esame, è molto semplice fare un \emph{Deploy} su dispositivo. Tramite \emph{NetBeans} bisogna configurare le SDK e scegliere il proprio dispositivo connesso tramite usb. Nel caso di iOS \emph{Apple} non concede l'installazione di applicazioni da origini sconosciute, a meno che non siano registrate sul Apple Store, pagando una tassa annuale di 99\$.
\end{description}
Quando il nostro progetto prende forma i file all'interno di esso cominciano a diventare consistenti e organizzarli diventa sempre più complesso. E buona norma di programmazione separare il proprio progetto in più file, ma al momento della consegna bisogna anche ricomporli e assemblarli nella maniera corretta. Inoltre se usiamo \emph{Ionic} e abbiamo modificato i fogli di stile dobbiamo ricordarci di ri-compilare i file \emph{SASS}.\\
Abbiamo constatato che prima di un deploy dell'applicazione ci sono una serie di operazioni che dobbiamo eseguire affinché il nostro progetto sia completo. Per fare questo ci serviamo di strumenti chiamati \emph{Tesk-Runner}.
\paragraph{Grunt/Gulp} \texttt{Grunt} e \texttt{Gulp} sono due esempi di \emph{task-tunner}. Ho voluto nominarli entrambi nella mia tesi in quanto il primo l'ho usato durante la mia esperienza di tirocinio, il secondo invece è usato dal framework  Ionic per la gestione di tutti i suoi file. Attualmente esistono due schiere di programmatori che sostengono che uno sia meglio dell'altro, personalmente preferisco grunt perché ha un logo più bello(hahaha).\\
Il ruolo dei task-runner non è ben preciso in quanto sono molto versatili e "assemblabili", in quanto per eseguire determinate operazioni necessitano dei loro plugin specifici. Ad esempio se nel mio progetto avessi bisogno di verificare la sintassi di Javascript, concatenare i file di progetto e le librerie, minificarli e spostarli in una cartella differente (ho potuto osservare durante il mio tirocinio che queste operazioni sono molto comode nel tipo di approccio che si ha nello sviluppo di una applicazione ibrida con tecnologie web) devo prima scaricare nel mio progetto ognuno di essi. Questo procedimento può sembrare poco efficiente, in realtà se disponiamo del \emph{Node Package Manager} NPM tutta la lista dei plugin installati nel progetto e registrata su un file \emph{package.json}. Inoltre una funzionalità molto significativa che hanno i task-runner è quella del \texttt{Live Reload}, ovvero sono in grado di vedere se ci sono stati cambiamenti nel nostro progetto e automaticamente eseguire le operazioni stabilite.
\subsubsection{Live Debug}
Una volta che l'applicazione è in esecuzione in una delle modalità descritte precedentemente ci si preoccupa di controllare che il codice che si ha scritto funzioni correttamente. Per eseguire un buon \emph{Debug} di questo tipo di applicazione è sufficiente disporre di uno strumento molto semplice \emph{Google Chrome}, infatti tramite questo web browser a diffenza di altri possiamo osservare il comportamento della nostra applicazione sui vari dispositivi(anche in fase di simulazione) come se stessimo facendo una normale ispezione di una pagine web. Ovviamente se l'applicazione è in \emph{Deploy sul Browser} il problema non si pone, qualsiasi browser può andare(anche se personalmente consiglio Google Chrome o Mozilla Firefox).
\subsection{SDK}
Un \texttt{Software Developement Kit} in generale è un insieme di strumenti per lo sviluppo e la documentazione del software\citeauthor{wiki:sdk}. Questi strumenti vengono rilasciati dalla casa produttrice di una certa piattaforma come librerie di riferimento per lo sviluppo di software specifico di essa. La loro distribuzione avviene in uno specifico linguaggio a seconda della piattaforma ed è sempre affiancata da una documentazione molto accurata.\\
Per lo sviluppo di applicazioni ibride avremo bisogno di ciascuna \emph{SDK} per ogni sistema operativo sul quale vorremo la nostra applicazione; ad esempio se volessimo la nostra applicazione per \emph{iOS} e \emph{Android} dovremmo scaricare entrambe le \emph{SDK}(scritte rispettivamente in C++/Swift e Java) indicando dove si trovano all'interno del notro computer. \emph{Nebeans} dispone di una interfaccia molto semplice da usare per impostare i percorsi delle \emph{SDK} ma non di tutte le piattaforme; se volgiamo impostare un'altra piattaforma non indicata nell'IDE dobbiamo seguire le istruzioni fornite da \emph{Cordova}.
\section{API Rest}
-- Tenclogia RESTFUL --\\
\subsection{Simple Rest Api}
-- Non ci occupiamo di costruire le API --\\
-- Uso delle API in angularJS --\\
-- JSON --\\
\subsection{XHR}
-- Cosè Cross Domanin --\\
-- POSTMAN --\\
-- Debug nel Browser --\\
\subsection{Firebase}
-- What, Why --\\
-- of course it's angular!! --\\
-- Ricollegarsi al discorso backend --