\chapter{Conclusioni}
\lhead{\emph{Capitolo 4}}
In questo capitolo verranno verificate le premesse e gli obiettivi dati all'inizio della tesi. In particolare verrà riportata l'analisi sulle tecnologie web per lo sviluppo ibrido multipiattaforma, mettendo a confronto gli altri metodi di sviluppo analizzati.
Verranno spiegati i cambiamenti che ci sono stati sul processo di sviluppo, avendo prefissato l'obiettivo di avere una applicazione mutlipiattaforma e quali ottimizzazioni sono state adottate. 

\section{Ibrido vs Nativo}
L'obiettivo di questa tesi è stato fin da subito quello di trovare delle metodologie rapide per sviluppare applicazioni multipiattaforma. L'approccio che è stato analizzato comprendeva l'utilizzo di tecnologie web per applicazioni ibride.
Effettivamente tramite l'impiego degli opportuni framework per la distribuzione di più piattaforme, è stato possibile partendo da un unico codice sorgente in HTML / CSS / Javascript ottenere il risultato desiderato.
Come spiegato nella sezione \ref{sec:native_vs_web} ci sono pro e contro sull'utilizzo di tecnologie web per lo sviluppo di applicazioni mobile. Tramite l'approccio ibrido è stato possibile combinare i vantaggi di questi due approcci, ma fino ad un certo punto. Nella tabella \ref{tbl:html5_vs_native} si possono osservare vantaggi e svantaggi derivati dai due approcci.

\begin{table}[h]
	\centering
	\begin{tabular}{|p{7.5cm}p{7.5cm}|}
		\hline
		\multicolumn{2}{|c|}{\textbf{Applicazioni}} \\ \hline
		\multicolumn{2}{|c|}{\cellcolor{black!10}\textbf{Ibride}}	  \\ \hline
  \cellcolor{green!35}
  \textbf{Pro} 
&
  \cellcolor{red!55}
  \textbf{Contro} 
\\ \hline
  \cellcolor{blue!25} 
  Le tecnologie web hanno una curva di apprendimento più bassa. Gli sviluppatori che vogliono usare tecnologie web per creare applicazioni mobile, impiegano meno tempo ad imparare il linguaggi (HTML / CSS / JS) rispetto ad uno nativo.
&
  \cellcolor{blue!10}
  Essendo Javascript un linguaggio interpretato all'interno della WebView di Webkit, sarà comunque meno performante di un linguaggio nativo compilato, nonostante un alta efficienza del motore. 
\\utilizzAppendiceare
  \cellcolor{blue!10}
  Permette di avere da un unico sorgente un'applicazione per ciascuna piattaforma, senza dover riscrivere il codice.
&
  \cellcolor{blue!25}
  Pur essendo un linguaggio facile, non si hanno strumenti altrettanto potenti 
  per poter fare debug del codice e memory profiling (anche se ultimamente stanno nascendo tool molto interessanti).
\\
  \cellcolor{blue!25}
  Grazie ai punti precedenti, può permettere un risparmio di tempi e costi, specialmente per la creazione di applicazioni multipiattaforma.
&
  \cellcolor{blue!10}
  L'accesso alle funzionalità native del dispositivo è vincolato dal wrapper che fornisce le API in Javascript. Dipende quindi dalla tecnologia che si va ad utilizzare.
\\\hline		
        \multicolumn{2}{|c|}{\cellcolor{black!10}\textbf{Native}} \\ \hline
  \cellcolor{green!35}
  \textbf{Pro} 
& 
  \cellcolor{red!55}
  \textbf{Contro} 
\\ \hline
  \cellcolor{blue!10}
  Tramite il linguaggio nativo della piattaforma, si può ottenere la massima performance in termini di potenza di calcolo e di sfruttamento del processore. 
& 
  \cellcolor{blue!25}
  E’ necessario riscrivere l'applicazione per ogni piattaforma che si intende supportare.
\\
  \cellcolor{blue!25}
  Sfrutta tutte le caratteristiche specifiche della piattaforma, sia in termini di software (librerie del produttore o di terze parti) che di hardware (del dispositivo o esterno)
&
  \cellcolor{blue!10}
  Richiede conoscenze specifiche dei vari linguaggi delle varie piattaforme da parte degli sviluppatori.
\\
  \cellcolor{blue!10}
  Si ha un accesso più a basso livello della piattaforma, cosa che spesso non è consentita alle API per ragioni di sicurezza.
&
  \cellcolor{blue!25}
  A causa dei punti precedenti può comportare un maggiore costo complessivo e l'allungamento dei tempi di sviluppo, in particolare dovendo gestire più piattaforme.
\\ \hline
 
	\end{tabular}
	\caption{HTML5 vs Nativo, pro e contro dei due approcci}
	\label{tbl:html5_vs_native}
\end{table}

Per quanto riguarda la creazione di una interfaccia utente e l'impostazione della user experience, si accusa spesso l'approccio ibrido di non poter garantire un risultato soddisfacente paragonato allo sviluppo nativo. Le principali accuse che vengono fatte ad una interfaccia web tramite approccio ibrido, riguardano la fluidità delle transizioni e animazioni, e di non garantire una UX ottimale. In questo caso mi permetto di dissentire da questa opinione, in quanto dalla mia esperienza di utilizzo dei framework web per la creazione della UI (come ad esempio IONIC o Foundation), l'interfaccia risulta fluida e accattivante anche se eseguita all'interno di una WebView. Se si fa utilizzo di animazioni CSS3 (il quale processo di rendering è accelerato dall'hardware), invece della manipolazione del DOM tramite javascript, la differenza con una applicazione nativa è pressoché nulla.

\section{I cambiamenti sul processo di sviluppo}
Durante la ricerca di soluzioni per lo sviluppo rapido di applicazioni multipiattaforma tramite l'approccio ibrido, il processo di sviluppo dell'applicazione ha subito una consistente semplificazione. Questo è dovuto al fatto che, avendo un solo progetto da gestire, dal quale poi si otterranno le applicazioni per diverse piattaforme, le varie operazioni di design, test o risoluzione di bachi risultano più rapide e semplici. Nella figura \ref{fig:classic_app_flow} viene schematizzato come avviene il processo di creazione di una applicazione in generale. In particolare la semplificazione del progetto è dovuta a:

\begin{figure}
	\begin{center}
		\includegraphics[scale=0.5]{Figures/classic_app_flow.pdf}
		\caption[Schema generale]{In questo schema sono illustrate le fasi generiche dello sviluppo di una applicazione}
		\label{fig:classic_app_flow}
	\end{center}
\end{figure}

\begin{description}
	\item[Design] Il design dell'applicazione rimane univoco e non ci si deve preoccupare di replicarlo per le diverse piattaforme.
	\item[Test] Avendo un unico codice sorgente, i test funzionali sull'applicazione sono unici, rimangono differenziati solo i test sull'integrazione nei singoli sistemi.
	\item[Team di sviluppo ristretto] Con un solo progetto da gestire il team di sviluppo è meno affollato, facilitandone la sua gestione.
	\item[Distribuzione] Tutte le applicazioni sono pronte nello stesso momento. In questo modo si ha subito un feedback globale da parte degli utenti, cosa che può eventualmente aiutare a correggere l'applicazione più rapidamente.
\end{description}

\section{Ulteriori otimizzazioni dell'approcio ibrido}

Nello sviluppo di una applicazione in generale, tutte le figure professionali coinvolte fanno riferimento ad uno schema generale, che illustra le fasi di lavoro per arrivare al prodotto finale. Da quanto appreso durante l'esperienza di tirocinio in azienda, questo schema deve essere il più generico possibile, e comprensibile da chiunque lavori con esso. Nella figura \ref{fig:classic_app_flow} si possono osservare le fasi principali dello sviluppo di una applicazione.

Prendendo spunto da questo schema generale ho creato una espansione della fase di sviluppo e di test per la realizzazione di applicazioni multipiattaforma ibride. Si tratta di un sottoschema che evidenzia quali fasi hanno caratterizzato un primo approccio a questo tipo di sviluppo (\ref{fig:flow_match}).

Una prima fase è stata quella di scegliere quali tecnologie web utilizzare per lo sviluppo ibrido, e quali per testare il codice che doveva essere prodotto. Nel mio caso il framework AngularJS si prestava già ad uno sviluppo di questo tipo e non ho impiegato molto tempo nel capire come utilizzarlo per lo sviluppo mobile. In altri casi, data la vasta scelta di framework javascript per lo sviluppo mobile, può richiedere parecchio tempo(dipende dalle competenze e dallo stile del programmatore).

Certamente iterare questo processo per ciascuna applicazione che si andrà a sviluppare è molto dispendioso in termini di tempo e risorse. Una buona soluzione e costruirsi un set di tecnologie che si andranno a utilizzare per lo sviluppo di ciascuna applicazione futura, quello che in azienda è stato chiamato \emph{skeleton}. Ovviamente lo scheletro di una applicazione tipo deve essere fatto in modo da espandersi nel caso giungessero richieste di nuove caratteristiche non ancora incluse. Nella figura \ref{fig:flow_match} si può osservare l'evoluzione del primo schema verso una soluzione pronta e rapida all'utilizzo, grazie all'introduzione dello \emph{skeleton}.

\begin{figure}
	\begin{center}
		\includegraphics[scale=0.5]{Figures/match_flow.pdf}
		\caption[Schemi di sviluppo a confronto]{Questo schema illustra l'evoluzione del primo schema verso una struttura più completa e multipiattaforma}
		\label{fig:flow_match}
	\end{center}
\end{figure}

Adottare questa pre-configurazione di tutte le tecnologie, mi ha portato a definire delle caratteristiche che lo scheletro di una applicazione deve avere, indipendentemente dalle tecnologie e i linguaggi utilizzati:

\begin{description}
\item[Dipendenze] Lo scheletro di una applicazione deve specificare tutte le dipendenze con software o pacchetti esterni. Per semplificare la loro gestione è possibile utilizzare dei package manager come Bower (\ref{sec:package_manager}) o Composer

\item[Modulare] Se un certo numero di applicazioni richiedono una nuova funzionalità che non è ancora inclusa nello scheletro, ci deve essere la possibilità di poterla aggiungere per tutte le applicazioni future. Al contrario non tutti i nuovi moduli devono per forza essere inclusi nelle implementazioni successive.

\item[Strutturato] Deve avere innanzitutto una struttura ben accurata a livello di directory, in modo tale che i file possano essere separati nella maniera che lo sviluppatore ritiene più opportuna. Ad esempio in AngularJS e possibile separare il codice in diversi moduli. Ci sono diverse linee di pensiero che sostengono che la separazione del codice debba avvenire in maniera semantica per il ruolo che quel modulo ricopre (ad esempio un modulo potrebbe essere la gestione dell'autenticazione con le varie direttive e controller). Altri sostengono che i moduli debbano essere divisi in base al tipo delle struttura utilizzata (sempre nel caso di AngularJS nei vari moduli vengono raggruppati per controller, direttive, service \ldots).

\item[Documentato] Documentare come funziona il proprio scheletro di applicazione e tutte le sue caratteristiche, da modo ai collaboratori futuri di apprendere nel minor tempo possibile il suo funzionamento. Esistono delle tecnologie che, date le giuste annotazioni nel codice, creano già una documentazione chiara e dettagliata.

\item[Automazione] E utile avere all'interno dello scheletro di una applicazione un meccanismo di automazione, tramite dei comandi (ad esempio usando shell-scripting), per operazioni come: set-up dell'ambiente di sviluppo, aggiornamento dei pacchetti, operazioni del task runner e risoluzione delle dipendenze.

\end{description} 

\section{Nuove tecnologie web emergenti}
In conclusione alla mia tesi voglio mostrare quali sono alcune delle tecnologie emergenti in ambito web per lo sviluppo di applicazioni mobile e non solo. Si tratta solo di una breve presentazione, se si vuole approfondire i vari riferimenti sono disponibili dei link nella bibliografia.
\subsection{FirefoxOS}

\begin{wrapfigure}{r}{0.40\textwidth}
	\vspace{-55pt}
	\begin{center}
		\includegraphics[scale=0.075]{Figures/fxos-logo.png}
	\end{center}
	\vspace{0pt}
	\caption{\\FirefoxOS logo}
	\label{fig:fxos_logo}
	\vspace{0pt}
\end{wrapfigure}

FirefoxOS è un nuovo sistema operativo per dispositivi mobili sviluppato da \emph{Mozilla}. Firefox OS ha eliminato lo strato di API native fra il sistema operativo e gli strati applicativi. Questa soluzione integrata riduce il carico della piattaforma e semplifica la gestione della sicurezza senza sacrificare le prestazioni e una ricca esperienza utente (fig.\ref{fig:fxos_architecture}). Voglio mostrare questa nuova tecnologia con particolare riferimento a come sono gestite le API del dispositivo. In particolare si può paragonare il funzionamento di questo sistema operativo al meccanismo di wrapping, utilizzato da alcuni framework per la distribuzione su più piattaforme della stessa applicazione ibrida.
In questo caso è tutto implementato nativamente, e non si ha bisogno di un wrapper per poter comunicare con le funzionalità del dispositivo, in quanto si ha il controllo totale del tramite delle API Javascript.
L'architettura di FirefoxOS mostrata nella figura \ref{fig:fxos_architecture} funziona in questo modo:  

\begin{figure}[h]
	\begin{center}
		\includegraphics[scale=0.30]{Figures/fxos-general-architecture-match.png}
		\caption[Architettura di FirefoxOS]{L'architettura di FirefoxOS messa a confronto con quella delle piattaforme proprietarie}
		\label{fig:fxos_architecture}
	\end{center}
\end{figure}

\begin{description}
	\item[Gaia] è l'insieme delle web app principali e dell'interfaccia utente di Firefox OS. È' scritto in HTML5, CSS e JavaScript. Espone un insieme di API per consentire al codice della UI di interagire con l'hardware del telefono e con le funzionalità di Gecko.
	\item[Gecko] è il motore web e lo strato di presentazione di Firefox OS. Rappresenta l'interfaccia fra i contenuti web e il dispositivo. Gecko fornisce il motore di parsing e rendering HTML5, un insieme di Web API sicure per accedere alle funzionalità hardware, un framework per la gestione della sicurezza, un sistema per la gestione degli aggiornamenti e altri servizi core.
	\item[Gonk] è il componente al livello del kernel nello stack di Firefox OS, è l'interfaccia fra Gecko e l'hardware del dispositivo. Gonk gestisce l'hardware sottostante e espone le funzionalità dell'hardware alle Web API implementate in Gecko. Gonk può essere visto come la “black box” che esegue il lavoro complesso e dettagliato dietro le scene, controllando il dispositivo mobile gestendo le richieste al livello hardware.
	Il dispositivo mobile è il telefono su cui viene eseguito Firefox OS. L'OEM è responsabile per la fornitura del dispositivo mobile.
\end{description}
\emph{fonte: Mozilla Developer Network}\cite{mdn:fxos}


\subsection{NodeWebkit}